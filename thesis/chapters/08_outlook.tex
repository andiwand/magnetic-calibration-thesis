In this chapter we want to discuss possible future work connected to this thesis. Besides implementation details that might improve performance directly, there is room for further research on the model and applications.

In our evaluation the particle filter was biased in some cases. Depending on the application this need further investigation. Animating the time evolution of the state space might help to understand the underlying problem.

Currently the time evolution of the hard iron effect is modelled as a random walk. A possible improvement would be to have an adaptive speed of the random walk depending on the strength of the external magnetic field. A further advanced model might be even able to predict the effect of the external field on the hard iron effect.

One application of this work is to develop an unbiased compass for smartphones in an indoor environment. Because of magnetic construction materials the measured magnetic field can differ highly from the Earth's magnetic field. Since the variation of the building's magnetic field acts on smaller scales than the one of the Earth it might be possible to distinguish between them. Calibrating the hard iron effect is a preliminary step that removes one bias from the Equation \ref{eq:decomposition}. Rather simple models for the building's magnetic field might be that it is small compared to the Earth's field or that it is very chaotic and might chancel out in summation over a long path.

As discovered during the work on this thesis, not all Android devices with a magnetometer will offer uncalibrated readings. This limits the scope of application for our particle filter. This is true for at least the Nokia 3 and the Motorola Moto G3. Using the system's calibrated magnetic field readings for further calibrations requires caution since it can be a new source of bias. It seems that the system calibration creates a discontinuous jump in the signal. It should be possible to filter this jump and to apply it to the state of the particle filter.

\section{Performance}

The particle filter is highly parallelizable because the particles are mostly independent. Only the resampling step usually requires interaction since a sum over all weights is performed.\cite{parallel_resampling}

Modern \glspl{cpu} come with special instructions for vectorization. Multiple operations, like vector addition, can be performed at the same time. This can speed up the execution significantly if that happens on critical path. Compiler Explorer\cite{compiler_explorer} can be used to check if such instructions are generated by the compiler.

Modern smartphones usually come with four processor cores or more. Those can be utilized by multithreading effectively. Usually that also requires synchronization which is error-prone and makes the program less readable.

Another possible optimization is to run the particle filter completely or parts of it on the \gls{gpu}. The \gls{gpu} is made for parallel and independent workloads and seems to fit well for this situation.\cite{parallel_resampling}

Performance is also related to battery consumption which is a critical resource for mobile devices. Depending on the application it might be not affordable to run a particle filter which is computational heavy by design.
