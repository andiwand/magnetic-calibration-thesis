% TODO kalman filter?
% TODO orientation error propagation

In this chapter we want to discuss possible future work connected to this thesis. Besides implementation details that might improve performance directly, there is room for further research on the model and applications.

In the evaluation our particle filter was biased in some cases. Depending on the application this need further investigation. Animating the time evolution of the state space might help to understand the underlying problem.

Currently the time evolution of the hard iron effect is modelled as a random walk. A possible improvement would be to have an adaptive speed for the random walk depending on the strength of the external magnetic field. More advanced models might even be able to predict the influence of the external field on the hard iron effect.

One application of this work is to develop an unbiased compass for smartphones in an indoor environment. Because of magnetic construction materials, the measured magnetic field can differ highly from the Earth's magnetic field. Since the variation of the building's magnetic field acts on much smaller scales than the one of the Earth, it might be possible to distinguish between them. Calibrating the hard iron effect is a preliminary step that removes one bias from the Equations \ref{eq:decomposition} and \ref{eq:decomposition_earth_env}. Simple models for the building's magnetic field might be that it is small compared to the Earth's field or that it is very chaotic and might cancel out in summation over a long path.

As discovered during the work on this thesis, not all Android devices with a magnetometer will offer ``uncalibrated'' readings, which do not contain hard iron compensation. Unfortunately, this limits the scope of application for our particle filter. This is true for at least the Nokia 3 and the Motorola Moto G3. Using the system's calibrated magnetometer readings for further calibrations requires caution, since it can be a new source of bias. It seems that the system calibration generates discontinuous jumps in the signal. It should be possible to filter these jumps and to propagate them into the state of the particle filter.

\section{Computational performance}

The particle filter is highly parallelizable because the particles are mostly independent. Only the resampling step usually requires interaction since a sum over all weights is performed.\cite{parallel_resampling}

Modern \glspl{cpu} come with special instructions for vectorization. Multiple operations, like vector addition, can be performed at the same time. This can speed up the execution time significantly if this happens on a critical path. Compiler Explorer\cite{compiler_explorer} can be used to check if such instructions are generated by the compiler.

Modern smartphones usually come with four processor cores or more. Those can be utilized by multithreading effectively. Usually that also requires synchronization which is error-prone and makes the program less readable.

Another possible optimization is to run the particle filter completely, or at least parts of it, on a \gls{gpu}. The \gls{gpu} is made for parallel and independent workloads and seems to fit well for this situation.\cite{parallel_resampling}

Performance is also related to battery consumption which is a critical resource for mobile devices. Depending on the application it might not be affordable to run a particle filter which is computational heavy by design.
