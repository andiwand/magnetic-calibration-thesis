// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: indoors/pipeline/protocol/message.proto

#ifndef PROTOBUF_INCLUDED_indoors_2fpipeline_2fprotocol_2fmessage_2eproto
#define PROTOBUF_INCLUDED_indoors_2fpipeline_2fprotocol_2fmessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto 

namespace protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto
namespace indoors {
namespace pipeline {
namespace protocol {
class Bye;
class ByeDefaultTypeInternal;
extern ByeDefaultTypeInternal _Bye_default_instance_;
class ChannelHello;
class ChannelHelloDefaultTypeInternal;
extern ChannelHelloDefaultTypeInternal _ChannelHello_default_instance_;
class Clock;
class ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Hello;
class HelloDefaultTypeInternal;
extern HelloDefaultTypeInternal _Hello_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace protocol
}  // namespace pipeline
}  // namespace indoors
namespace google {
namespace protobuf {
template<> ::indoors::pipeline::protocol::Bye* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Bye>(Arena*);
template<> ::indoors::pipeline::protocol::ChannelHello* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::ChannelHello>(Arena*);
template<> ::indoors::pipeline::protocol::Clock* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Clock>(Arena*);
template<> ::indoors::pipeline::protocol::Event* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Event>(Arena*);
template<> ::indoors::pipeline::protocol::Hello* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Hello>(Arena*);
template<> ::indoors::pipeline::protocol::Vector3* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Vector3>(Arena*);
template<> ::indoors::pipeline::protocol::Void* Arena::CreateMaybeMessage<::indoors::pipeline::protocol::Void>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace indoors {
namespace pipeline {
namespace protocol {

// ===================================================================

class Hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Hello) */ {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hello(Hello&& from) noexcept
    : Hello() {
    *this = ::std::move(from);
  }

  inline Hello& operator=(Hello&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hello* internal_default_instance() {
    return reinterpret_cast<const Hello*>(
               &_Hello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Hello* other);
  friend void swap(Hello& a, Hello& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hello* New() const final {
    return CreateMaybeMessage<Hello>(NULL);
  }

  Hello* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Hello>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .indoors.pipeline.protocol.ChannelHello channels = 2;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::indoors::pipeline::protocol::ChannelHello* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::indoors::pipeline::protocol::ChannelHello >*
      mutable_channels();
  const ::indoors::pipeline::protocol::ChannelHello& channels(int index) const;
  ::indoors::pipeline::protocol::ChannelHello* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::indoors::pipeline::protocol::ChannelHello >&
      channels() const;

  // string from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Hello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::indoors::pipeline::protocol::ChannelHello > channels_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bye : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Bye) */ {
 public:
  Bye();
  virtual ~Bye();

  Bye(const Bye& from);

  inline Bye& operator=(const Bye& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bye(Bye&& from) noexcept
    : Bye() {
    *this = ::std::move(from);
  }

  inline Bye& operator=(Bye&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bye& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bye* internal_default_instance() {
    return reinterpret_cast<const Bye*>(
               &_Bye_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Bye* other);
  friend void swap(Bye& a, Bye& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bye* New() const final {
    return CreateMaybeMessage<Bye>(NULL);
  }

  Bye* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bye>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Bye& from);
  void MergeFrom(const Bye& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bye* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Bye)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChannelHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.ChannelHello) */ {
 public:
  ChannelHello();
  virtual ~ChannelHello();

  ChannelHello(const ChannelHello& from);

  inline ChannelHello& operator=(const ChannelHello& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelHello(ChannelHello&& from) noexcept
    : ChannelHello() {
    *this = ::std::move(from);
  }

  inline ChannelHello& operator=(ChannelHello&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelHello& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelHello* internal_default_instance() {
    return reinterpret_cast<const ChannelHello*>(
               &_ChannelHello_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ChannelHello* other);
  friend void swap(ChannelHello& a, ChannelHello& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelHello* New() const final {
    return CreateMaybeMessage<ChannelHello>(NULL);
  }

  ChannelHello* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelHello>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelHello& from);
  void MergeFrom(const ChannelHello& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string annotation = 2;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 2;
  const ::std::string& annotation() const;
  void set_annotation(const ::std::string& value);
  #if LANG_CXX11
  void set_annotation(::std::string&& value);
  #endif
  void set_annotation(const char* value);
  void set_annotation(const char* value, size_t size);
  ::std::string* mutable_annotation();
  ::std::string* release_annotation();
  void set_allocated_annotation(::std::string* annotation);

  // .indoors.pipeline.protocol.Event eventExample = 3;
  bool has_eventexample() const;
  void clear_eventexample();
  static const int kEventExampleFieldNumber = 3;
  private:
  const ::indoors::pipeline::protocol::Event& _internal_eventexample() const;
  public:
  const ::indoors::pipeline::protocol::Event& eventexample() const;
  ::indoors::pipeline::protocol::Event* release_eventexample();
  ::indoors::pipeline::protocol::Event* mutable_eventexample();
  void set_allocated_eventexample(::indoors::pipeline::protocol::Event* eventexample);

  // uint32 channel = 1;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.ChannelHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr annotation_;
  ::indoors::pipeline::protocol::Event* eventexample_;
  ::google::protobuf::uint32 channel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  enum Case {
    kHello = 3,
    kBye = 4,
    kVoid = 5,
    kSwitch = 6,
    kScalar = 7,
    kClock = 8,
    kVector3 = 9,
    __NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double t = 1;
  void clear_t();
  static const int kTFieldNumber = 1;
  double t() const;
  void set_t(double value);

  // uint32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // .indoors.pipeline.protocol.Hello hello = 3;
  bool has_hello() const;
  void clear_hello();
  static const int kHelloFieldNumber = 3;
  private:
  const ::indoors::pipeline::protocol::Hello& _internal_hello() const;
  public:
  const ::indoors::pipeline::protocol::Hello& hello() const;
  ::indoors::pipeline::protocol::Hello* release_hello();
  ::indoors::pipeline::protocol::Hello* mutable_hello();
  void set_allocated_hello(::indoors::pipeline::protocol::Hello* hello);

  // .indoors.pipeline.protocol.Bye bye = 4;
  bool has_bye() const;
  void clear_bye();
  static const int kByeFieldNumber = 4;
  private:
  const ::indoors::pipeline::protocol::Bye& _internal_bye() const;
  public:
  const ::indoors::pipeline::protocol::Bye& bye() const;
  ::indoors::pipeline::protocol::Bye* release_bye();
  ::indoors::pipeline::protocol::Bye* mutable_bye();
  void set_allocated_bye(::indoors::pipeline::protocol::Bye* bye);

  // .indoors.pipeline.protocol.Void void = 5;
  bool has_void_() const;
  void clear_void_();
  static const int kVoidFieldNumber = 5;
  private:
  const ::indoors::pipeline::protocol::Void& _internal_void_() const;
  public:
  const ::indoors::pipeline::protocol::Void& void_() const;
  ::indoors::pipeline::protocol::Void* release_void_();
  ::indoors::pipeline::protocol::Void* mutable_void_();
  void set_allocated_void_(::indoors::pipeline::protocol::Void* void_);

  // bool switch = 6;
  private:
  bool has_switch_() const;
  public:
  void clear_switch_();
  static const int kSwitchFieldNumber = 6;
  bool switch_() const;
  void set_switch_(bool value);

  // double scalar = 7;
  private:
  bool has_scalar() const;
  public:
  void clear_scalar();
  static const int kScalarFieldNumber = 7;
  double scalar() const;
  void set_scalar(double value);

  // .indoors.pipeline.protocol.Clock clock = 8;
  bool has_clock() const;
  void clear_clock();
  static const int kClockFieldNumber = 8;
  private:
  const ::indoors::pipeline::protocol::Clock& _internal_clock() const;
  public:
  const ::indoors::pipeline::protocol::Clock& clock() const;
  ::indoors::pipeline::protocol::Clock* release_clock();
  ::indoors::pipeline::protocol::Clock* mutable_clock();
  void set_allocated_clock(::indoors::pipeline::protocol::Clock* clock);

  // .indoors.pipeline.protocol.Vector3 vector3 = 9;
  bool has_vector3() const;
  void clear_vector3();
  static const int kVector3FieldNumber = 9;
  private:
  const ::indoors::pipeline::protocol::Vector3& _internal_vector3() const;
  public:
  const ::indoors::pipeline::protocol::Vector3& vector3() const;
  ::indoors::pipeline::protocol::Vector3* release_vector3();
  ::indoors::pipeline::protocol::Vector3* mutable_vector3();
  void set_allocated_vector3(::indoors::pipeline::protocol::Vector3* vector3);

  void clear__();
  Case __case() const;
  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Event)
 private:
  void set_has_hello();
  void set_has_bye();
  void set_has_void_();
  void set_has_switch_();
  void set_has_scalar();
  void set_has_clock();
  void set_has_vector3();

  inline bool has__() const;
  inline void clear_has__();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double t_;
  ::google::protobuf::uint32 channel_;
  union Union {
    Union() {}
    ::indoors::pipeline::protocol::Hello* hello_;
    ::indoors::pipeline::protocol::Bye* bye_;
    ::indoors::pipeline::protocol::Void* void__;
    bool switch__;
    double scalar_;
    ::indoors::pipeline::protocol::Clock* clock_;
    ::indoors::pipeline::protocol::Vector3* vector3_;
  } __;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Void : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Void* other);
  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(NULL);
  }

  Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Void)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Clock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Clock) */ {
 public:
  Clock();
  virtual ~Clock();

  Clock(const Clock& from);

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(Clock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Clock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Clock* other);
  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Clock* New() const final {
    return CreateMaybeMessage<Clock>(NULL);
  }

  Clock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Clock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Clock& from);
  void MergeFrom(const Clock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double unix_utc = 1;
  void clear_unix_utc();
  static const int kUnixUtcFieldNumber = 1;
  double unix_utc() const;
  void set_unix_utc(double value);

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Clock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double unix_utc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:indoors.pipeline.protocol.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Vector3* other);
  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(NULL);
  }

  Vector3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:indoors.pipeline.protocol.Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_indoors_2fpipeline_2fprotocol_2fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hello

// string from = 1;
inline void Hello::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hello::from() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Hello.from)
  return from_.GetNoArena();
}
inline void Hello::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Hello.from)
}
#if LANG_CXX11
inline void Hello::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:indoors.pipeline.protocol.Hello.from)
}
#endif
inline void Hello::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:indoors.pipeline.protocol.Hello.from)
}
inline void Hello::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:indoors.pipeline.protocol.Hello.from)
}
inline ::std::string* Hello::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Hello.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_from() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Hello.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:indoors.pipeline.protocol.Hello.from)
}

// repeated .indoors.pipeline.protocol.ChannelHello channels = 2;
inline int Hello::channels_size() const {
  return channels_.size();
}
inline void Hello::clear_channels() {
  channels_.Clear();
}
inline ::indoors::pipeline::protocol::ChannelHello* Hello::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Hello.channels)
  return channels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::indoors::pipeline::protocol::ChannelHello >*
Hello::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:indoors.pipeline.protocol.Hello.channels)
  return &channels_;
}
inline const ::indoors::pipeline::protocol::ChannelHello& Hello::channels(int index) const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Hello.channels)
  return channels_.Get(index);
}
inline ::indoors::pipeline::protocol::ChannelHello* Hello::add_channels() {
  // @@protoc_insertion_point(field_add:indoors.pipeline.protocol.Hello.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::indoors::pipeline::protocol::ChannelHello >&
Hello::channels() const {
  // @@protoc_insertion_point(field_list:indoors.pipeline.protocol.Hello.channels)
  return channels_;
}

// -------------------------------------------------------------------

// Bye

// -------------------------------------------------------------------

// ChannelHello

// uint32 channel = 1;
inline void ChannelHello::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 ChannelHello::channel() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.ChannelHello.channel)
  return channel_;
}
inline void ChannelHello::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.ChannelHello.channel)
}

// string annotation = 2;
inline void ChannelHello::clear_annotation() {
  annotation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChannelHello::annotation() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.ChannelHello.annotation)
  return annotation_.GetNoArena();
}
inline void ChannelHello::set_annotation(const ::std::string& value) {
  
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.ChannelHello.annotation)
}
#if LANG_CXX11
inline void ChannelHello::set_annotation(::std::string&& value) {
  
  annotation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:indoors.pipeline.protocol.ChannelHello.annotation)
}
#endif
inline void ChannelHello::set_annotation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:indoors.pipeline.protocol.ChannelHello.annotation)
}
inline void ChannelHello::set_annotation(const char* value, size_t size) {
  
  annotation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:indoors.pipeline.protocol.ChannelHello.annotation)
}
inline ::std::string* ChannelHello::mutable_annotation() {
  
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.ChannelHello.annotation)
  return annotation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelHello::release_annotation() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.ChannelHello.annotation)
  
  return annotation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelHello::set_allocated_annotation(::std::string* annotation) {
  if (annotation != NULL) {
    
  } else {
    
  }
  annotation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), annotation);
  // @@protoc_insertion_point(field_set_allocated:indoors.pipeline.protocol.ChannelHello.annotation)
}

// .indoors.pipeline.protocol.Event eventExample = 3;
inline bool ChannelHello::has_eventexample() const {
  return this != internal_default_instance() && eventexample_ != NULL;
}
inline void ChannelHello::clear_eventexample() {
  if (GetArenaNoVirtual() == NULL && eventexample_ != NULL) {
    delete eventexample_;
  }
  eventexample_ = NULL;
}
inline const ::indoors::pipeline::protocol::Event& ChannelHello::_internal_eventexample() const {
  return *eventexample_;
}
inline const ::indoors::pipeline::protocol::Event& ChannelHello::eventexample() const {
  const ::indoors::pipeline::protocol::Event* p = eventexample_;
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.ChannelHello.eventExample)
  return p != NULL ? *p : *reinterpret_cast<const ::indoors::pipeline::protocol::Event*>(
      &::indoors::pipeline::protocol::_Event_default_instance_);
}
inline ::indoors::pipeline::protocol::Event* ChannelHello::release_eventexample() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.ChannelHello.eventExample)
  
  ::indoors::pipeline::protocol::Event* temp = eventexample_;
  eventexample_ = NULL;
  return temp;
}
inline ::indoors::pipeline::protocol::Event* ChannelHello::mutable_eventexample() {
  
  if (eventexample_ == NULL) {
    auto* p = CreateMaybeMessage<::indoors::pipeline::protocol::Event>(GetArenaNoVirtual());
    eventexample_ = p;
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.ChannelHello.eventExample)
  return eventexample_;
}
inline void ChannelHello::set_allocated_eventexample(::indoors::pipeline::protocol::Event* eventexample) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eventexample_;
  }
  if (eventexample) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventexample = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventexample, submessage_arena);
    }
    
  } else {
    
  }
  eventexample_ = eventexample;
  // @@protoc_insertion_point(field_set_allocated:indoors.pipeline.protocol.ChannelHello.eventExample)
}

// -------------------------------------------------------------------

// Event

// double t = 1;
inline void Event::clear_t() {
  t_ = 0;
}
inline double Event::t() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.t)
  return t_;
}
inline void Event::set_t(double value) {
  
  t_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Event.t)
}

// uint32 channel = 2;
inline void Event::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 Event::channel() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.channel)
  return channel_;
}
inline void Event::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Event.channel)
}

// .indoors.pipeline.protocol.Hello hello = 3;
inline bool Event::has_hello() const {
  return __case() == kHello;
}
inline void Event::set_has_hello() {
  _oneof_case_[0] = kHello;
}
inline void Event::clear_hello() {
  if (has_hello()) {
    delete __.hello_;
    clear_has__();
  }
}
inline const ::indoors::pipeline::protocol::Hello& Event::_internal_hello() const {
  return *__.hello_;
}
inline ::indoors::pipeline::protocol::Hello* Event::release_hello() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Event.hello)
  if (has_hello()) {
    clear_has__();
      ::indoors::pipeline::protocol::Hello* temp = __.hello_;
    __.hello_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::indoors::pipeline::protocol::Hello& Event::hello() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.hello)
  return has_hello()
      ? *__.hello_
      : *reinterpret_cast< ::indoors::pipeline::protocol::Hello*>(&::indoors::pipeline::protocol::_Hello_default_instance_);
}
inline ::indoors::pipeline::protocol::Hello* Event::mutable_hello() {
  if (!has_hello()) {
    clear__();
    set_has_hello();
    __.hello_ = CreateMaybeMessage< ::indoors::pipeline::protocol::Hello >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Event.hello)
  return __.hello_;
}

// .indoors.pipeline.protocol.Bye bye = 4;
inline bool Event::has_bye() const {
  return __case() == kBye;
}
inline void Event::set_has_bye() {
  _oneof_case_[0] = kBye;
}
inline void Event::clear_bye() {
  if (has_bye()) {
    delete __.bye_;
    clear_has__();
  }
}
inline const ::indoors::pipeline::protocol::Bye& Event::_internal_bye() const {
  return *__.bye_;
}
inline ::indoors::pipeline::protocol::Bye* Event::release_bye() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Event.bye)
  if (has_bye()) {
    clear_has__();
      ::indoors::pipeline::protocol::Bye* temp = __.bye_;
    __.bye_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::indoors::pipeline::protocol::Bye& Event::bye() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.bye)
  return has_bye()
      ? *__.bye_
      : *reinterpret_cast< ::indoors::pipeline::protocol::Bye*>(&::indoors::pipeline::protocol::_Bye_default_instance_);
}
inline ::indoors::pipeline::protocol::Bye* Event::mutable_bye() {
  if (!has_bye()) {
    clear__();
    set_has_bye();
    __.bye_ = CreateMaybeMessage< ::indoors::pipeline::protocol::Bye >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Event.bye)
  return __.bye_;
}

// .indoors.pipeline.protocol.Void void = 5;
inline bool Event::has_void_() const {
  return __case() == kVoid;
}
inline void Event::set_has_void_() {
  _oneof_case_[0] = kVoid;
}
inline void Event::clear_void_() {
  if (has_void_()) {
    delete __.void__;
    clear_has__();
  }
}
inline const ::indoors::pipeline::protocol::Void& Event::_internal_void_() const {
  return *__.void__;
}
inline ::indoors::pipeline::protocol::Void* Event::release_void_() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Event.void)
  if (has_void_()) {
    clear_has__();
      ::indoors::pipeline::protocol::Void* temp = __.void__;
    __.void__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::indoors::pipeline::protocol::Void& Event::void_() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.void)
  return has_void_()
      ? *__.void__
      : *reinterpret_cast< ::indoors::pipeline::protocol::Void*>(&::indoors::pipeline::protocol::_Void_default_instance_);
}
inline ::indoors::pipeline::protocol::Void* Event::mutable_void_() {
  if (!has_void_()) {
    clear__();
    set_has_void_();
    __.void__ = CreateMaybeMessage< ::indoors::pipeline::protocol::Void >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Event.void)
  return __.void__;
}

// bool switch = 6;
inline bool Event::has_switch_() const {
  return __case() == kSwitch;
}
inline void Event::set_has_switch_() {
  _oneof_case_[0] = kSwitch;
}
inline void Event::clear_switch_() {
  if (has_switch_()) {
    __.switch__ = false;
    clear_has__();
  }
}
inline bool Event::switch_() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.switch)
  if (has_switch_()) {
    return __.switch__;
  }
  return false;
}
inline void Event::set_switch_(bool value) {
  if (!has_switch_()) {
    clear__();
    set_has_switch_();
  }
  __.switch__ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Event.switch)
}

// double scalar = 7;
inline bool Event::has_scalar() const {
  return __case() == kScalar;
}
inline void Event::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Event::clear_scalar() {
  if (has_scalar()) {
    __.scalar_ = 0;
    clear_has__();
  }
}
inline double Event::scalar() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.scalar)
  if (has_scalar()) {
    return __.scalar_;
  }
  return 0;
}
inline void Event::set_scalar(double value) {
  if (!has_scalar()) {
    clear__();
    set_has_scalar();
  }
  __.scalar_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Event.scalar)
}

// .indoors.pipeline.protocol.Clock clock = 8;
inline bool Event::has_clock() const {
  return __case() == kClock;
}
inline void Event::set_has_clock() {
  _oneof_case_[0] = kClock;
}
inline void Event::clear_clock() {
  if (has_clock()) {
    delete __.clock_;
    clear_has__();
  }
}
inline const ::indoors::pipeline::protocol::Clock& Event::_internal_clock() const {
  return *__.clock_;
}
inline ::indoors::pipeline::protocol::Clock* Event::release_clock() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Event.clock)
  if (has_clock()) {
    clear_has__();
      ::indoors::pipeline::protocol::Clock* temp = __.clock_;
    __.clock_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::indoors::pipeline::protocol::Clock& Event::clock() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.clock)
  return has_clock()
      ? *__.clock_
      : *reinterpret_cast< ::indoors::pipeline::protocol::Clock*>(&::indoors::pipeline::protocol::_Clock_default_instance_);
}
inline ::indoors::pipeline::protocol::Clock* Event::mutable_clock() {
  if (!has_clock()) {
    clear__();
    set_has_clock();
    __.clock_ = CreateMaybeMessage< ::indoors::pipeline::protocol::Clock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Event.clock)
  return __.clock_;
}

// .indoors.pipeline.protocol.Vector3 vector3 = 9;
inline bool Event::has_vector3() const {
  return __case() == kVector3;
}
inline void Event::set_has_vector3() {
  _oneof_case_[0] = kVector3;
}
inline void Event::clear_vector3() {
  if (has_vector3()) {
    delete __.vector3_;
    clear_has__();
  }
}
inline const ::indoors::pipeline::protocol::Vector3& Event::_internal_vector3() const {
  return *__.vector3_;
}
inline ::indoors::pipeline::protocol::Vector3* Event::release_vector3() {
  // @@protoc_insertion_point(field_release:indoors.pipeline.protocol.Event.vector3)
  if (has_vector3()) {
    clear_has__();
      ::indoors::pipeline::protocol::Vector3* temp = __.vector3_;
    __.vector3_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::indoors::pipeline::protocol::Vector3& Event::vector3() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Event.vector3)
  return has_vector3()
      ? *__.vector3_
      : *reinterpret_cast< ::indoors::pipeline::protocol::Vector3*>(&::indoors::pipeline::protocol::_Vector3_default_instance_);
}
inline ::indoors::pipeline::protocol::Vector3* Event::mutable_vector3() {
  if (!has_vector3()) {
    clear__();
    set_has_vector3();
    __.vector3_ = CreateMaybeMessage< ::indoors::pipeline::protocol::Vector3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:indoors.pipeline.protocol.Event.vector3)
  return __.vector3_;
}

inline bool Event::has__() const {
  return __case() != __NOT_SET;
}
inline void Event::clear_has__() {
  _oneof_case_[0] = __NOT_SET;
}
inline Event::Case Event::__case() const {
  return Event::Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Clock

// double unix_utc = 1;
inline void Clock::clear_unix_utc() {
  unix_utc_ = 0;
}
inline double Clock::unix_utc() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Clock.unix_utc)
  return unix_utc_;
}
inline void Clock::set_unix_utc(double value) {
  
  unix_utc_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Clock.unix_utc)
}

// -------------------------------------------------------------------

// Vector3

// double x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Vector3.x)
  return x_;
}
inline void Vector3::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Vector3.x)
}

// double y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Vector3.y)
  return y_;
}
inline void Vector3::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Vector3.y)
}

// double z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:indoors.pipeline.protocol.Vector3.z)
  return z_;
}
inline void Vector3::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:indoors.pipeline.protocol.Vector3.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace pipeline
}  // namespace indoors

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_indoors_2fpipeline_2fprotocol_2fmessage_2eproto
